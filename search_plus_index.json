{"./":{"url":"./","title":"gitbook","keywords":"","body":"Road Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-30 14:03:00 "},"content/chapter-1/第一章Nodejs.html":{"url":"content/chapter-1/第一章Nodejs.html","title":"第一章 Nodejs","keywords":"","body":"第一章 Nodejs 从本章开始，我们就正式开启JavaScript的后端开发之旅。 Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。 众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。 后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。（2001年推出的古老的IE 6到今天仍然有人在使用！） 没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可改进之处，然后解散了IE6开发团队！而Google却认为支持现代Web应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行JavaScript的引擎性能还可提升10倍。 先是Mozilla借助已壮烈牺牲的Netscape遗产在2002年推出了Firefox浏览器，紧接着Apple于2003年在开源的KHTML浏览器的基础上推出了WebKit内核的Safari浏览器，不过仅限于Mac平台。 随后，Google也开始创建自家的浏览器。他们也看中了WebKit内核，于是基于WebKit内核推出了Chrome浏览器。 Chrome浏览器是跨Windows和Mac平台的，并且，Google认为要运行现代Web应用，浏览器必须有一个性能非常强劲的JavaScript引擎，于是Google自己开发了一个高性能JavaScript引擎，名字叫V8，以BSD许可证开源。 现代浏览器大战让微软的IE浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队！回过头再追赶却发现，支持HTML5的WebKit已经成为手机端的标准了，IE浏览器从此与主流移动端设备绝缘。 浏览器大战和Node有何关系？ 话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。 因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。 选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。 于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。 在Node上运行的JavaScript相比其他后端开发语言有何优势？ 最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。 其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。 io.js 因为Node.js是开源项目，虽然由社区推动，但幕后一直由Joyent公司资助。由于一群开发者对Joyent公司的策略不满，于2014年从Node.js项目fork出了io.js项目，决定单独发展，但两者实际上是兼容的。 然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent公司表示要和解，于是，io.js项目又决定回归Node.js。 具体做法是将来io.js将首先添加新的特性，如果大家测试用得爽，就把新特性加入Node.js。io.js是“尝鲜版”，而Node.js是线上稳定版，相当于Fedora Linux和RHEL的关系。 注明：上述转自廖雪峰老师的博客，有兴趣的同学可以去围观 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-30 14:03:00 "},"content/chapter-1/section/1.1.html":{"url":"content/chapter-1/section/1.1.html","title":"1.1 认识Nodejs","keywords":"","body":"1.1 认识Nodejs 1.1.1 什么是Nodejs？     Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. (Node.js 是一个基于 Chrome V8 引擎的 JavaScript运行环境。) 1.1.2 Nodejs和js的区别？ Node.js是平台，Js是编程语言 组成区别 Node.js ECMAScript V8 LIBUV javascript ECMAScript DOM BOM 运行环境 nodejs运行在【服务器】上 javascript运行在【浏览器内核】中 全局对象 在node环境下 - - global 在浏览器环境下是 - - window 1.1.3 运行在浏览器端的JS能做什么 DOM操作 文档操作 BOM操作 浏览器操作 表单验证 数据交互 ajax jsonp xhr2(CORS) canvas 动画 ... 1.1.4 运行在服务器端的JS能做什么 主要用于做中间件 转发请求 文件操作 系统操作 数据库操作 搭建服务 ... 1.1.5 nodejs的特点 基于非阻塞的I/O模型 Input/Output 运行环境是单线程 阻塞操作 异步处理(回调函数) 1.1.6 nodejs应用场景 高并发请求 web开发 winform开发 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-30 14:03:00 "},"content/chapter-1/section/1.2.html":{"url":"content/chapter-1/section/1.2.html","title":"1.2 实例一","keywords":"","body":"实例一 项目介绍 简单搭建服务器 模拟简单实现页面登录/页面注册功能 项目源代码 代码 1（createServer.js） const http = require('http'); const path = require('path'); const fs = require('fs'); const { readFile } = require('../../lib/readfile'); const querystring = require('querystring'); http.createServer((req, res) => { if (req.url === '/favicon.ico') return //过滤图标 res.writeHead(200, { \"content-type\": \"text/html;charset=utf-8\" }); if (req.method === 'GET') { switch (req.url) { case '/': readFile('src/html/index.html').then(data => res.end(data)).catch(err => console.log(err)); break; case '/reg.html': readFile('src/html/reg.html').then(data => res.end(data)).catch(err => console.log(err)); break; case '/login.html': readFile('src/html/login.html').then(data => res.end(data)).catch(err => console.log(err)); break; case '/style/reg.css': res.writeHead(200, { \"content-type\": \"text/css;charset=utf-8\" }); readFile('src/style/reg.css').then(data => res.end(data)).catch(err => console.log(err)) break; } } else { switch (req.url) { case '/reg.html': req.on('data', data => { //1.data.toString()数字转字符串 //2.querystring.parse()能把一个 URL 查询字符串（str）解析成一个键值对的集合。 let userdata = querystring.parse(data.toString()) //引入readFile模块 读取json文件 这里json存的是一个数组 readFile('./lib/userdata.json').then(data => { if (data) data = JSON.parse(data); //过滤 let exist = data.filter(val => { return val.name === userdata.name }) // 判断是否存在 if (exist.length) { res.end('{\"msg\":\"用户名已存在\"}'); } else { data.push(userdata); fs.writeFile(path.join(__dirname, '../../lib/userdata.json'), JSON.stringify(data), err => { if (err) throw err; res.end('{\"msg\":\"注册成功\"}'); }) } }).catch(err => console.log(err)) }) break; case '/login.html': req.on('data', data => { let userdata = querystring.parse(data.toString()); readFile('./lib/userdata.json').then(jsondata => { jsondata = JSON.parse(jsondata); let exist = jsondata.some(val => { return val.name === userdata.name && val.password == userdata.password; }) if (exist) { res.end('{\"msg\":\"登陆成功\"}'); } else { res.end('{\"msg\":\"账号或用户名输入有误\"}'); } }).catch(err => console.log(err)) }) } } }).listen(8888, () => { console.log('server is running on http://localhost8888'); }); 代码 2 (userdata.json) [{\"name\":\"admin\",\"password\":\"123\"},{\"name\":\"root\",\"password\":\"123\"}] 代码 3 (readFile.js) const fs = require('fs'); const path = require('path'); function readFile() { let url = path.join(__dirname, '..', ...arguments); return new Promise((resolve, reject) => { fs.readFile(url, 'utf8', (err, data) => { err && reject(err); resolve(data); }); }); } module.exports = { readFile }; Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-30 14:03:00 "},"content/chapter-2/第二章API文档.html":{"url":"content/chapter-2/第二章API文档.html","title":"第二章 NodejsAPI文档","keywords":"","body":"Node.js API文档 assert - 断言 async_hooks - 异步钩子 Buffer - 缓冲器 child_process - 子进程 cluster - 集群 console - 控制台 crypto - 加密 debugger - 调试器 dgram - 数据报 dns - 域名服务器 domain - 域 Error - 异常 events - 事件触发器 fs - 文件系统 global - 全局变量 http - HTTP http2 - HTTP/2 https - HTTPS inspector - 检查器 module - 模块 net - 网络 os - 操作系统 path - 路径 perf_hooks - 性能钩子 process - 进程 punycode - 域名代码 querystring - 查询字符串 readline - 逐行读取 repl - 交互式解释器 stream - 流 string_decoder - 字符串解码器 timer - 定时器 tls - 安全传输层 trace_events - 跟踪事件 tty - 终端 url - URL util - 实用工具 v8 - V8引擎 vm - 虚拟机 worker_threads - 工作线程 zlib - 压缩 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-30 15:47:45 "},"content/chapter-2/section/2.1.fs.html":{"url":"content/chapter-2/section/2.1.fs.html","title":"2.1 File System(文件系统)","keywords":"","body":"File System(文件系统) 内置模块 fs 模块提供了一个 API，用于以模仿标准 POSIX 函数的方式与文件系统进行交互。 要使用此模块： const fs = require('fs'); 1. fs.readFile(path[, options], callback) 读文件 const fs = require('fs'); const path = require('path'); function readFile() { let url = path.join(__dirname, '..', ...arguments); return new Promise((resolve, reject) => { fs.readFile(url, 'utf8', (err, data) => { err && reject(err); resolve(data); }); }); } module.exports = { readFile }; 2. fs.writeFile(file, data[, options], callback) 写文件 const fs = require('fs'); const path = require('path'); fs.writeFile(path.join(__dirname, 'helloworld.txt'), 'hello world!', (err) => { if (err) throw err; console.log('文件写入成功'); }); 3. fs.appendFile(path, data[, options], callback) 异步地将数据追加到文件，如果文件尚不存在则创建该文件。 data 可以是字符串或 Buffer。 const fs = require('fs'); const path = require('path'); let data = 'hello word!'; fs.appendFile(path.join(__dirname, './helloworld.txt'), data, err => { if (err) throw err; console.log('追加成功'); }); 4. fs.rename(oldPath, newPath, callback) 异步地将 oldPath 上的文件重命名为 newPath 提供的路径名。 如果 newPath 已存在，则覆盖它。 除了可能的异常，完成回调没有其他参数。 const fs = require('fs'); const path = require('path'); let oldpath = path.join(__dirname, 'test.txt'); let newpath = path.join(__dirname, 'test.html'); fs.rename(oldpath, newpath, err => { if (err) throw err; console.log('文件名修改成功'); }); 5. fs.readdir(path[, options], callback) 读取目录的内容。 回调有两个参数 (err, files)，其中 files 是目录中的文件名的数组（不包括 '.' 和 '..'） const fs = require('fs'); const path = require('path'); fs.readdir(path.join(__dirname, 'img'), (err, files) => { if (err) throw err; console.log(files); }) 6. fs.mkdir(path[, options], callback) 异步地创建目录。 可选的 options 参数可以是指定模式（权限和粘滞位）的整数，也可以是具有 mode 属性和 recursive 属性（指示是否应创建父文件夹）的对象。 ```javascript const fs = require('fs'); fs.mkdir('/tmp/a/apple', (err) => { if (err) throw err; }); ### 7. fs.unlink(path, callback) >异步地删除文件或符号链接。 ```javascript const fs = require('fs'); fs.unlink('path/file.txt', (err) => { if (err) throw err; console.log('文件已删除'); }); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-30 15:42:00 "},"content/chapter-2/section/2.2.path.html":{"url":"content/chapter-2/section/2.2.path.html","title":"2.2 path(路径))","keywords":"","body":"path(路径) 内置模块 path 模块提供用于处理文件路径和目录路径的实用工具。 它可以使用以下方式访问： const path = require('path'); 1. path.basename(path[,ext]) path.basename() 方法返回 path 的最后一部分 path.basename('/foo/bar/baz/asdf/quux.html'); // 返回: 'quux.html' path.basename('/foo/bar/baz/asdf/quux.html', '.html'); // 返回: 'quux' 2. path.dirname(path) path.dirname() 方法返回 path 的目录名 path.dirname('/foo/bar/baz/asdf/quux'); // 返回: '/foo/bar/baz/asdf' 3. path.extname(path) path.extname() 方法返回 path 的扩展名 path.extname('index.html'); // 返回: '.html' path.extname('index.coffee.md'); // 返回: '.md' path.extname('index.'); // 返回: '.' path.extname('index'); // 返回: '' path.extname('.index'); // 返回: '' path.extname('.index.md'); // 返回: '.md' Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-30 15:41:40 "},"content/chapter-2/section/2.3.http.html":{"url":"content/chapter-2/section/2.3.http.html","title":"2.3 http(HTTP))","keywords":"","body":"http（HTTP） 内置模块 const http = require('http'); 1. http.createServer([options][, requestListener]) const http = require('http'); const path = require('path'); const port = 8888; const server = http.createServer((req, res) => { // req request 请求 和前端相关 // console.log(req.url); if (req.url === '/favicon.ico') return; // console.log(req.method); // console.log(req.headers.host); let url = path.join(req.headers.host, req.url); console.log(`${req.method} ${url}`); // res response 响应 和后端相关 res.writeHead(200, { \"content-type\": \"text/html;charset=utf-8\" }); res.write('hello world'); //发送响应内容 res.write('你好世界'); //发送响应内容 res.end('end'); //响应结束 }); server.listen(port, () => { console.log(`http server is running on http://localhost:${port}`); }); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-30 16:17:11 "},"content/chapter-3/第三章实例.html":{"url":"content/chapter-3/第三章实例.html","title":"第三章 实例","keywords":"","body":"第三章 实例 3.1 router 3.2 mongoose/ JsonWebToken Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-12-10 22:00:21 "},"content/chapter-3/section/3.1.router.html":{"url":"content/chapter-3/section/3.1.router.html","title":"3.1 路由","keywords":"","body":"3.1 路由 const http = require('http'); const path = require('path'); const fs = require('fs'); const querystring = require('querystring'); const readFile = require('./lib/readfile'); http.createServer((req, res) => { if (req.url === '/favicon.ico') return; let url = path.join(req.headers.host, req.url); console.log(`${req.method} ${url}`); // 打印请求地址 和请求方式 res.writeHead(200, { \"content-type\": \"text/html;charset=utf-8\" }); // 设置响应头 switch (req.url) { case '/': readFile('public', 'html', 'index.html').then((data) => { res.end(data); }, (err) => { res.end('404!'); }) break; case '/users': readFile('public', 'html', 'users.html').then((data) => { res.end(data); }, (err) => { res.end('404!'); }) break; case '/jquery.min.js': readFile('node_modules', 'jquery', 'dist', 'jquery.min.js').then((data) => { res.end(data); }) break; case '/index.css': res.writeHead(200, { \"content-type\": \"text/css;charset=utf-8\" }) readFile('public', 'css', 'index.css').then((data) => { res.end(data); }, (err) => { res.end('404!'); }) break; case '/weather': // 服务器代理 weather(req, res); break; } }).listen(8888, () => { console.log('http server is running on http://localhost:8888'); }); function weather(request, response) { console.log(1); let opt = { app: \"weather.future\", weaid: \"hangzhou\", appkey: \"38926\", sign: \"f8b4121c2d581be2623569b24f798dee\", format: \"json\" } const options = { hostname: 'api.k780.com', //主机名 port: 80, // 端口号 path: `/?${querystring.stringify(opt)}`, //路径 method: 'GET', //请求方式 }; const req = http.request(options, (res) => { let data = ''; res.setEncoding('utf8'); // 设置字符编码 res.on('data', (chunk) => { // 事件 接收到数据 执行函数 // chunk 数据块 data += chunk; }); res.on('end', () => { // 事件 响应结束 执行 response.end(data); }); }); req.on('error', (e) => { //错误事件 console.error(`problem with request: ${e.message}`); }); req.end(); // 请求结束 } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-30 16:17:13 "},"content/chapter-3/section/3.2mongoose.html":{"url":"content/chapter-3/section/3.2mongoose.html","title":"3.1 mongoose/ JsonWebToken","keywords":"","body":"3.2 $$mongoose/ JsonWebToken 3.2.1 项目介绍 express 实现身份验证(登录/注册) JWT mongoDB数据库的CRUD 3.2.2 简介 JWT【 全称： JsonWebToken 】 用户登录 服务器端产生一个token (加密字符串) 发送给前端 前端将token 进行保存 前端发起数据请求的时候携带token $$ 服务端 验证token 是否合法 如果合法继续操作 不合法终止操作 token 的使用场景 无状态请求 保持用户的登录状态 第三方登录（token+auth2.0） 非对称加密 通过私钥产生token 通过公钥解密token 产生私钥 openssl genrsa -out ./private_key.pem 1024 1024 代表私钥长度 产生公钥 openssl rsa -in ./private_key.pem -pubout -out ./public_key.pem 3.2.3 实战讲解 $ npx express -e . //npx -> 临时使用 . -> 当前文件下 $ npm i package.json-> \"scripts\": { \"start\": \"nodemon ./bin/www\"//改成nodemon 便于后续调试 } $ npm i jsonwebtoken -S //在目录下新建rsa文件夹 用于存放公钥和私钥 ./[rsa] $ cd rsa // 创建公钥和私钥 --相应的应用程序 请前往官网下载 //产生私钥 $ openssl genrsa -out ./private_key.pem 1024 //产生公钥 $ openssl rsa -in ./private_key.pem -pubout -out ./public_key.pem 基本部署完毕，接下来开始愉快的敲到代码了！ 在[fe]/login.html (fe->front end) 在fe文件夹下新建login.html fe文件夹新建在apache服务下 设置路由[be]/login.js Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-01-03 09:54:26 "},"content/chapter-4/第四章第三方模块.html":{"url":"content/chapter-4/第四章第三方模块.html","title":"第四章 第三方模块","keywords":"","body":"第四章 第三方模块 插件官网 https://www.npmjs.com/ 常用插件 1. cheerio --(Fast, flexible & lean implementation of core jQuery designed specifically for the server.) 2. express --(Fast, unopinionated, minimalist web framework for node.) 3. cors --(CORS is a node.js package for providing a Connect/Express middleware that can be used to enable CORS with various options.) 4. request --(Request is designed to be the simplest way possible to make http calls. It supports HTTPS and follows redirects by default.) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-12-02 21:58:39 "},"content/chapter-4/section/4.1.cheerio.html":{"url":"content/chapter-4/section/4.1.cheerio.html","title":"4.1 cherrio","keywords":"","body":"cheerio 简介 Fast, flexible & lean implementation of core jQuery designed specifically for the server. 链接 https://www.npmjs.com/package/cheerio 安装 $ npm i cheerio -S 实例一：爬取京东图片 const fs = require('fs'); const path = require('path'); const cheerio = require('cheerio'); const https = require('https'); https.get('https://www.jd.com/', (res) => { const { statusCode } = res; const contentType = res.headers['content-type']; let error; if (statusCode !== 200) { error = new Error('请求失败\\n' + `状态码: ${statusCode}`); } else if (!/^text\\/html/.test(contentType)) { error = new Error('无效的 content-type.\\n' + `期望的是 text/html 但接收到的是 ${contentType}`); } if (error) { console.error(error.message); // 消费响应数据来释放内存。 res.resume(); return; } res.setEncoding('utf8'); let rawData = ''; res.on('data', (chunk) => { rawData += chunk; }); res.on('end', () => { const $ = cheerio.load(rawData); let reg = /^(\\/\\/)|^(http:\\/\\/)/; $('img').each((i, elm) => { let url = $(elm).attr('src').replace(reg, 'https://'); //统一协议 let filename = url.split('/').pop(); https.get(url, (res) => { let data = ''; res.on('data', (chunk) => { data += chunk; }); res.setEncoding('binary') res.on('end', () => { fs.writeFile(path.join(__dirname, '../img', filename), data, 'binary', err => { if (err) console.log(err); console.log('创建成功'); }) }) }) }) }); }).on('error', (e) => { console.error(`出现错误: ${e.message}`); }); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-12-02 21:59:48 "},"content/chapter-4/section/4.2.express.html":{"url":"content/chapter-4/section/4.2.express.html","title":"4.2 express","keywords":"","body":"express 简介 Fast, unopinionated, minimalist web framework for node. 链接 https://www.npmjs.com/package/express 安装 $ npm i express -S 实例一：解决跨域一 const express = require('express'); const app = express(); const hostname = 'localhsot'; const port = 8888; app.get('/', (req, res) => { res.send('index'); }); app.get('/user', (req, res) => { res.setHeader('Access-Control-Allow-Origin', '*');//解决跨域方法一：加响应头 res.send('用户界面'); }) app.listen(port, () => console.log(`server is running http://${hostname}:${port}`)) Document $.ajax({ type: \"get\", url: \"http://localhost:8888/user\", // data: \"data\", // dataType: \"dataType\", success: function (response) { console.log(response); } }); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-12-02 22:13:45 "},"content/chapter-4/section/4.3.cors.html":{"url":"content/chapter-4/section/4.3.cors.html","title":"4.3 cors","keywords":"","body":"cheerio 简介 CORS is a node.js package for providing a Connect/Express middleware that can be used to enable CORS with various options. 链接 https://www.npmjs.com/package/cors 安装 $ npm i cors -S 实例一：解决跨域二 const express = require('express'); const cors = require('cors'); const hostname = 'localhsot'; const app = express(); app.use(cors()) app.get('/cors', (req, res) => { res.send('cors') }) app.listen(8888, () => { console.log('server is running '); }) Document $.ajax({ type: \"get\", url: \"http://localhost:8888/cors\", // data: \"data\", // dataType: \"dataType\", success: function (response) { console.log(response); } }); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-12-02 22:10:29 "},"content/chapter-4/section/4.4.request.html":{"url":"content/chapter-4/section/4.4.request.html","title":"4.4 request","keywords":"","body":"request 简介 Request is designed to be the simplest way possible to make http calls. It supports HTTPS and follows redirects by default. 链接 https://www.npmjs.com/package/request 安装 $ npm i request -S 实例一：请求未来5天杭州天气 const request = require('request'); const express = require('express'); const querystring = require('querystring'); const app = express(); const weather = querystring.stringify({ app: 'weather.future', weaid: 'hangzhou', appkey: '45185', sign: '39fe4d457610819dbbd69dac15a53e4f', format: 'json' }) app.get('/index', (req, res) => { request(`http://api.k780.com/?${weather}`, function (error, response, body) { console.log('error:', error); // Print the error if one occurred console.log('statusCode:', response && response.statusCode); // Print the response status code if a response was received // console.log('body:', body); // Print the HTML for the Google homepage. res.send(body) }); }) app.listen(8888, () => { console.log('server is running'); }) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-12-02 22:13:14 "}}